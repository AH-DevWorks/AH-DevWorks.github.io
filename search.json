[{"content":"❌ 所有的 DML 都可以在 View 上操作 Simple View ==\u003e 滿足下列條件，才可以用DML 只有一個Base Table，沒有JOIN 沒有使用Function(SUM, AVG等)或分組(GROUP BY, DISTINCT 等) Updateable 可更新 Complex View NO DML ✅ Foreign Key 可由多個欄位組成 可以由多個欄位組成複合外鍵（Composite Foreign Key），只要這些欄位對應參照表的一組 PK 或 UK 即可 p.s. FK可以是NULL空值 DDL (Data Definition Language) CREATE, DROP, ALTER, RENAME, TRUNCATE DML (Data Manipulation Language) INSERT, UPDATE, DELETE, *SELECT *註: 亦有分類將 SELECT 單獨歸類為 DQL (Data Query Language) DCL (Data Control Language) GRANT, REVOKE TCL (Transaction Control Language) COMMIT, ROLLBACK, SAVEPOINT SQL 語法順序 ≠ 實際執行順序 語法順序ex. SELECT name, COUNT(*) as order_count FROM orders WHERE status = 'completed' GROUP BY name HAVING COUNT(*) \u003e 5 ORDER BY order_count DESC LIMIT 10; 實際執行順序 Logical Execution Order FROM -- 1. WHERE -- 2. GROUP BY -- 3. HAVING -- 4. SELECT -- 5.※ ORDER BY -- 6.所以ORDER BY 裡可用 SELECT 定義的 column別名 LIMIT -- 7. ⚠ MySQL 實作上會提前解析 SELECT 子句中的別名：可看成SELECT在第3順位 SELECT employee_name Name, department_id D_ID, MAX(salary) M_sal FROM employees WHERE hiredate \u003e '2011-02-01' GROUP BY Name, D_ID -- 可以用別名Name, D_ID HAVING M_sal \u003e 1600 -- 可以用別名 m_sal ORDER BY Name LIMIT 3; ''' ↓ SELECT 提前解析 ''' FROM WHERE SELECT -- \u003c-- ※ GROUP BY -- 以下幾個都可用column別名 HAVING ORDER BY LIMIT ","description":"重點觀念複習","tags":["learning","sql"],"title":"SQL Test - Review","uri":"/notes/2025/sql_review_20250504/"},{"content":" 上課老師說時間不夠，這兩項目講不到，就當作延伸。\n自學後做了些紀錄。\n目錄 CTE(Common Table Expression) Window Function CTE(Common Table Expression) 一般資料表運算式 說明 CTE是 SQL 裡的一種臨時結果集 「暫存」且「具名」的結果集合，透過AS關鍵字將查詢結果暫時儲存 創建後可在SELECT、INSERT、UPDATE、DELETE等處使用，讓查詢邏輯更清晰、可讀性更高 【基本語法】 WITH CTE名稱 AS ( SELECT 查詢語句 ) SELECT * FROM CTE名稱; 【基本範例1：查各部門平均薪資，按部門分類】 -- CTE WITH cte_name AS ( SELECT Department, AVG(Salary) AS AvgSalary FROM Employees GROUP BY Department ) SELECT * FROM cte_name; -- 使用上面創的CTE 【基本範例2：查出薪資高於全體平均薪資的員工】 WITH avg_salary AS ( SELECT AVG(sal) AS avg_sal FROM emp ) SELECT e.* FROM employees e CROSS JOIN avg_salary a WHERE e.salary \u003e a.avg_sal; CTE 用於 Tree Recursion 樹狀結構遞迴 CTE適用在處理遞迴資料結構，或整理複雜查詢邏輯 【範例：查出公司內部從老闆開始，往下每層的隸屬關係】 WITH RECURSIVE employee_hierarchy AS ( -- 單只寫 NULL 會被推斷成字元長度太短，所以明確指定型別: CONVERT(NULL, CHAR(25)) -- 這裡CONVERT()預設型別不能使用 VARCHAR --\u003e MySQL本身的限制，能用固定size的CHAR，但可變長度的VARCHAR不能處理 -- 加level只是方便把各員工所屬層級看得更清楚 SELECT id, name, manager_id, CAST(NULL AS CHAR(25)) AS manager_name, 1 AS level FROM employees WHERE manager_id IS NULL -- 初始層級：BOSS (沒有上級mgr(manager)) UNION ALL -- 遞迴層級：找出每一層的下屬 SELECT e.id, e.name, e.manager_id, h.name AS manager_name, h.level + 1 FROM employees e JOIN employee_hierarchy h ON e.manager_id = h.id ) SELECT * FROM employee_hierarchy ORDER BY level; CTE vs. Subquery 項目 CTE（Common Table Expression） Subquery（子查詢） 語法位置 使用 WITH 開頭，通常在主查詢之前 可以寫在 FROM、WHERE、SELECT 等處 可重用性 定義好的CTE可在同一個查詢中重複使用 無法重複使用；每次都要寫完整的查詢內容 可讀性 較佳，易於拆解複雜邏輯 當巢狀太深時，可讀性較差 支援遞迴 ✅ 可使用 WITH RECURSIVE ❌ 不支援遞迴 效能差異 理論上差不多，實際依資料庫優化器與查詢內容而異 一般查詢引擎也會優化 subquery 為臨時表格 參考資料：SQL語法 - CTE 一般資料表運算式（COMMON TABLE EXPRESSION） Window Function 窗口函數／視窗函數 說明 SQL 中的一種分析工具，可以針對每一列資料，計算其在某個「資料視窗（window）」中的統計結果，而不會將資料壓縮成單一列 「在資料列上滑動『一個局部範圍』進行計算」（e.g.每個部門的薪資排名、累積總和等） 【基本語法】 \u003cWindow_Function_name\u003e(欄位) OVER ( [PARTITION BY 分組欄位] [ORDER BY 排序欄位] [ROWS BETWEEN ...] ) PARTITION BY: 把資料按照某欄位分組形成多個「window」，然後在每一組中各自執行視窗函數邏輯 跟GROUP BY不同：GROUP BY後資料筆數通常會減少；PARTITION BY後資料筆數不變、結合原本欄位。 GROUP BY不能搭配Window Function PARTITION BY 可以省略 –\u003e 表示「整張table為一個視窗」，window function 會對所有資料列共同計算（如下聚合型的範例2） 常見的 Window Function Aggregate-style 聚合型：SUM(), COUNT(), AVG(), MAX(), MIN() Ranking 排序型：ROW_NUMBER(), RANK(), DENSE_RANK() Value Offset 位移型：LAG(), LEAD(), FIRST_VALUE(), LAST_VALUE() 聚合型 Window Function 在一般查詢 / GROUP BY 語境下也可用，但在 Window Function語境下，不會壓縮rows\n【範例1：加總每個部門的銷售總額（每列都顯示）】 SELECT employee_id, department, amount, SUM(amount) OVER (PARTITION BY department) AS total_in_dept FROM sales; -- 顯示每筆銷售及所在部門的總銷售金額 【範例2：排序各員工薪資佔人事總成本的百分比】 -- 省略PARTITION BY 的用法 SELECT id, name, job, salary, CONCAT(ROUND(salary/SUM(salary) OVER() * 100, 2), '%') AS personnel_costs_percent FROM employee ORDER BY salary DESC; -- 高到低排序 排序型 Window Function ROW_NUMBER(): 給每一行一個不重複的序號，且就算指定比對的數值一樣（如score都=1000），仍會排出高低次序。\nSELECT *, ROW_NUMBER() OVER (ORDER BY salary DESC) AS sal_row_rank FROM employee; 所以各 row 再多加明確排序欄位（如 ROW_NUMBER() OVER (ORDER BY SALARY DESC, ID ASC)）比較好 ==\u003e 避免同值之間「非確定性」（nondeterministic）的先後順序。 RANK(): 相較於ROW_NUMBER()，RANK()會把同數值的項目給予同編號，且若序號重複，往後序號會跳號 (ex. 1,2,2,4,5,…)\nSELECT *, RANK() OVER (ORDER BY salary DESC) AS sal_row_rank FROM employee; DENSE_RANK(): 類似RANK()，但重複不跳號 (ex. 1,2,2,3,4,…)\nSELECT *, DENSE_RANK() OVER (ORDER BY salary DESC) AS sal_row_rank FROM employee; NTILE(n): （或歸類在分析型）分位排序，把資料依照參數(正整數n)拆成n組(tiles)，每組儘量平均放入數量儘量相同的資料、且依序給予序號 常用在需要分等第/區間的情況 若data總筆數不能被n整除，前幾組會多一筆資料 -- 將所有員工依照薪水高到低排序，分成4組，並且標示每筆屬於哪一組 SELECT employee_id, salary, NTILE(4) OVER (ORDER BY salary DESC) AS salary_quartile FROM employee; 位移型 Window Function 這類函數會取排序之後的上一筆、下一筆或特定位置的值，方便做時間序列比較、成長率分析等\n透過 SELF JOIN 也能達成類似結果（但外觀看起來不太一樣）\nLAG() OVER (PARTITION BY ... ORDER BY ...)：把資料往後移動，用來與上一列資料比較 LAG( [ 要位移的欄位 ], [ 位移列數 ], [ 沒資料時的預設值 ] ) LEAD() OVER (PARTITION BY ... ORDER BY ...): 把資料往前移動，用來與下一列資料比較 FIRST_VALUE(column_name) OVER (PARTITION BY ... ORDER BY ...)：查詢該分區第一列資料 LAST_VALUE(column_name) OVER (PARTITION BY ... ORDER BY ...)：查詢該分區最後一列資料 -- 找出各部門裡「最早錄用員工的錄用日期」，分別顯示在各部門員工欄位右側 SELECT name, DATE(hiredate), department_id, DATE(FIRST_VALUE(hiredate) OVER (PARTITION BY department_id)) AS dept_earliest_hiredate FROM employee; 參考資料： SQL 窗口函數 Window Function：三大應用快速教學 ","description":"SQL 自學筆記——CTE＆Window Function","tags":["learning","SQL","CTE","Window Function"],"title":"SQL - CTE(Common Table Expression)＆Window Function","uri":"/post/2025/sql/cte_and_windowfunction_20250503/"},{"content":"第二週：4/14、4/15、4/17、4/19 It is not things themselves that disturb us, but our opinions about them. — Epictetus\n相同功能/達成結果相同情況下，Recursive (call stack) 比for loop更占記憶體空間（∵Heap）\nRecursive 每一次呼叫，程式會分配一塊stack frame(堆疊空間)給該函數，並保留目前狀態，等待下一層遞迴回傳後再繼續執行 導致每層呼叫都佔據一些記憶體 for loop 每個只要一次函數呼叫的堆疊空間，不會有額外的函數呼叫堆疊 除非每圈都創造很多objects，否則使用空間是固定的 python有堆疊上限: 預設1000層(可用 sys.getrecursionlimit() 查看) import sys print(sys.getrecursionlimit()) 超過就會 RecursionError: maximum recursion depth exceeded in comparison → 無法回傳或Crash或記憶體爆炸 函式也可指派給變數 –\u003e 類似代數中「變數可以代表一個值」的觀念\n函式也是物件（objects） def square(x): return x * x def cube(x): return x * x * x def operate(func, value): return func(value) print(operate(square, 3)) # 9 print(operate(cube, 3)) # 27 Higher-order Functions(高階函式): 「接受其他function作為參數」或「回傳function作為結果」的Function python內建如map(func, iterable)、filter(func, iterable)、sorted(iterable, key=func) lambda\nAnonymous Function （匿名函式）的一種 結構：lambda parameters : expression Web Crawling BeautifulSoup select() vs. find() select(): CSS 選擇器風格查詢，可單區塊深入查內層 可用 CSS selector 語法（ex. div \u003e span.title） find(): 條件搜尋式，用 tag 名、class、id 當參數，查詢廣範圍但難深入 # 用 find() 抓到區塊，再用 select() 查裡面的內容 box = soup.find(\"div\", class_=\"container\") title = box.select_one(\"span.title\") # select_one 會直接回傳單一元素 package(browser-cookie3) 針對需要登入才能瀏覽的網站\n自動fetch瀏覽器cookies\nimport browser_cookie3, requests # 從 Chrome 瀏覽器中取得 cookies cj = browser_cookie3.chrome() # 回傳一個 cookie jar # 帶著 cookies 發送 GET 請求 res = requests.get('https://example.com', cookies=cj) print(res.text) 登入了一個網站（例如 Twitter、Google、Facebook 等）後，browser-cookie3可借用(存在本機的)瀏覽器登入的 cookies (session token)去存取相同網站的資料 適用於爬某些私人頁面（如個人FB 、學校系統等），但要小心 dynamic website e.g. nownews – 找點擊「載入更多」後的request url 抓多頁==\u003e 抓網址id規律 規律不明顯的話就抓大概，搭配去重(都存進set；或用dict，把每篇url最後id當成key也可以) Pandas 儲存格式 parquet format: 列式儲存格式，I/O效率高、壓縮比高、儲存空間小；通常搭配 pyarrow 或 fastparquet python pickle format: python自己的物件序列化格式；跨語言、跨平台、跨版本python不一定相容；適合快速暫存；安全風險–不明來源的pickle可能被植入惡意代碼 自補充 Separate data (or settings/configuration) from logic 把邏輯和資料分開 「關注點分離」（Separation of Concerns） 把 Logic(處理流程、資料運算、檔案操作等核心功能) 跟 Settings(target 名稱、輸出位置、參數開關等使用者可修改的項目) 分開 良好習慣 不要把一些可變的參數（像使用者指定的輸出檔案檔名、ID、URL等）硬寫在程式碼裡面，而是要集中放在一個設定檔（config file）裡管理 ❌程式碼中某一行直接寫： target = \"123\" # 請自行更改檔案名稱 filename = f\"{target}.txt\" ✅使用設定檔如 config.json，再讓程式讀檔： { \"target\": \"123\" } import json with open(\"config.json\", \"r\", encoding=\"utf-8\") as f: config = json.load(f) target = config[\"target\"] filename = f\"{target}.txt\" Prevention事前預防 vs. Recovery事後處理 e.g.讓使用者輸入數字 ==\u003e 避免輸入非數字 Prevention: 用regex檢查 避免 try-except 的開銷（雖然通常微乎其微） 適合「錯誤不是預期中流程的一部分」的場景（例如輸入驗證） 缺點：要自己處理各種邊界條件（空字串、負號、小數點、全形字元……） import re user_input = input(\"請輸入數字: \") if re.fullmatch(r'\\d+', user_input): # re.fullmatch--\u003e整串輸入都要符合規則 number = int(user_input) else: print(\"Error: 請輸入合法的整數\") Recovery: try-except 更符合 「EAFP」（Easier to Ask Forgiveness than Permission）原則 —— 一種 Python 的設計哲學 相對於EAFP \u003c—\u003e LBYL(Look Before You Leap) 精簡、直觀：直接嘗試做「你希望做的事」，失敗再處理 缺點：對於Expected Errors(預期性錯誤，非常常見、幾乎一定會發生)來說，不夠精準（會包住太多可能錯誤） Prevention: 使用者輸入 / 格式驗證；邏輯精密 / 錯誤類型需精細掌握者 Recovery: 無法預測的錯誤（網路錯誤、檔案損壞）；簡單任務 / 不在乎精細錯誤類型 其他自學 Hello 演算法\n實體書\n岡野原大輔 (2024). 精確掌握 AI 大趨勢！深度學習技術解密：日本 AI 神人，帶你正確學會從機器學習到生成式 AI 的核心基礎 (王心薇 \u0026 施威銘研究室, Trans.). 旗標. Ceder, N. (2019). Python 技術者們：練功！老手帶路教你精通正宗 Python 程式 (張耀鴻, Trans.). 旗標. Udemy線上課程\nAPI(Application Programing Interface, 應用程式界面) API Endpoint: location, URL Request 【library】: requests .raise_for_status(): (當如果不是200通過) raise一個requests.exceptions.HTTPError，讓使用者集中處理API請求時的HTTP errors e.g. International Space Station Current Location http status code: 1xx: hold on 2xx: here you go 3xx: go away 4xx: you screwed up 5xx: the site screwed up HTML Entities – HTML特殊字元編碼表/字符實體 避免跟HTML特殊字元混淆，如 \u003c 須改用HTML Entity的寫法：\u0026lt; import html unescaped_words = html.unescape(escaped_str) tkinter self.false_button = Button(image=self.cross_img, highlightthickness=0, command=self.quiz.check_answer(\"False\")): 後半部不能command=self.quiz.check_answer(\"False\")，command要的是method名稱，要到按鈕點擊時才會執行function，原本寫法會等於是「馬上執行 check_answer(“False”)」 –\u003e 可用lambda寫法或是另外定義一個def func引入 李宏毅【生成式AI時代下的機器學習(2025)】\n李宏毅【生成式AI導論 2024】\n張成龍【MySQL資料庫從零開始玩轉】\n","description":"當周學習與生活雜記","tags":["learning","journal"],"title":"轉職路：AI養成班 Week 2.","uri":"/notes/2025/weekly_journal_202504_2/"},{"content":"Python實作 Bubble Sort ※排序演算法(Sorting Algorithm)是將資料依特定規則進行重新排列的演算法，通常是依照資料的大小進行排列，Bubble Sort是其中之一。\n※資料排序後，就能進一步對其進行更有效率的分析或搜尋。如「二分搜尋法」在資料數較多時，效率高於循序搜尋，但執行二分搜尋之前，必須先將原始資料排序。\n程式碼 def user_input_check(message): while True: try: user_input = input(message) if '.' not in user_input: return int(user_input) else: return float(user_input) except ValueError: print(\"請輸入正確的數字...\") def bubble_sort(number_list): for i in range(1, len(number_list)): print(f\"### 第{i}輪 ###\") for j in range(len(number_list) - i): if number_list[j] \u003e number_list[j + 1]: number_list[j], number_list[j + 1] = number_list[j + 1], number_list[j] print(f\"\u003e\u003e資料狀態: {number_list}\") print(\"-------------------\") return number_list print(\"———請輸入以下資訊———\") data_length = 0 while data_length \u003c= 0: data_length = int(user_input_check(\"資料總數量：\\n\")) data_list = [] for num in range(data_length): data_list.append(user_input_check(f\"第{num + 1}筆資料: \")) print(f\"\\n\\n原始資料:{data_list}\") print(\"-------------------\") sorted_list = bubble_sort(data_list.copy()) print(f\"排序後資料: {sorted_list}\") 執行畫面 說明 上面程式碼是自己練習寫的，可能不是最好的bubble sort寫法 user_input_check(message): 輸入檢查，跟bubble sort無關，只是習慣放 bubble_sort(number_list): 排序法本體，外層 for loop 控制排序的輪數，每輪最後會把一個最大值排到最右側；內層 for loop 進行相鄰元素比較與交換 值得一提是中間 number_list[j], number_list[j + 1] = number_list[j + 1], number_list[j] ，這種寫法是Python特有的，涉及 tuple 型別的 packing / unpacking ，一行就能交換兩變數值 如果是其他程式語言，要兩數互換大多需要再一個temp變數，分三行如 temp=var1、var1=var2、var2=temp 從巢狀for loop就能看出bubble sort的時間複雜度是O(n²)，效率差，實務上基本沒人會用。但就入門迴圈邏輯＆資料操作思維來說，應該還是有幫助。至少我希望有幫助…✏️ ","description":"氣泡排序法（泡沫排序法）練習","tags":["learning","algorithm","sorting","bubble sort"],"title":"Python 實作 Bubble Sort","uri":"/post/2025/algorithm/bubble_sort_20250414/"},{"content":"第一週：4/7、4/8、4/10、4/12 自我介紹環節，有不少資訊本科系或做過科技業，甚至還有自費生，真心佩服。 簡單翻了一下歷屆學長姐成果，從電腦視覺到混合應用的都有。該來想想專題的主題了（小組專題＆個人的Side Project）。希望結訓後履歷至少能塞滿一整頁。 使用者家目錄 C:\\Users\\[USER-NAME]\\ // 動態（隨登入者變化） // 登入者(USER)對家目錄有最高權限 Adding Python Path to Environment Variables Zero Trust pypi.org encode/decode history: ASCII -\u003e BIG-5 -\u003e Unicode(UTF-8/UTF-16…) character set（字元集） f-string: {}(Curly Brackets)內必須為expression (表達式) statement(敘述句,如print())等無回傳值的不應放入(會None) str.format() (\"[pattern]\".format(a,b,c…)) print(\"他是 {}，今年 {} 歲。\".format(\"Johnny\", 88)) # 輸出：他是 Johnny，今年 88 歲。 float非精準數，比對時以區間比對較佳 a = 100.0 b = 11.11 / 0.1111 print(f\"a 等於 b ? --\u003e {a == b}\") # a 等於 b ? --\u003e False print(f\"a: {a} | b: {b}\") # a: 100.0 | b: 99.99999999999999 eval() x = eval(input(\"Input:\")) # eval()自動評估數字型別＆轉換 # 不適用非數字 match-case rating = 5 match rating: case 1: print(\"第1名，獎金10,000元！\") case 2: print(\"第2名，獎金5,000元\") case 3 | 4 | 5 as number: # 後置宣告 -- as print(f\"佳作(第{number}名)，獎金500元\") case _: print(\"下次再接再厲！\") # Tuple niceSeasons = (\"春\", \"秋\") match niceSeasons: # 元素順序要一致，否則比對失敗: case (\"秋\", \"春\"): print(\"溫和季節\") case _: print(\"季節比對失敗\") 自補充 f-string 細節 若數字num是正整數如 7 ，f\"{num:02d}\" 和 f\"{num:0\u003e2}\" 結果看起來會一樣 num = 7 print(f\"{num:02d}\") # 07 print(f\"{num:0\u003e2}\") # 07 但兩種 format 背後邏輯不一樣： num:02d –\u003e 數值格式化 : 「將變數 num 格式化成一個 最小寬度為 2 位數 的十進位整數(Decimal Integer)，如果不足 2 位，則在前面補 0 。 num:0\u003e2 –\u003e 字串對齊格式化 : 「把 num 轉成 string 後，向右對齊(\u003e)，若num轉成string後，長度沒達到設定的『最小寬度』 2 ，則在左側補 0 直到寬度達標為止」。 因此如果碰到負數等特殊情況，第二種方式可能會出現錯誤的顯示，如： i = -42 print(f\"{i:05d}\") # ✅-0042 print(f\"{i:0\u003e5}\") # ❗00-42 p.s. num:0\u003e2 這種方式，若num本身長度就大於設定的「最小寬度(2)」，則Python 會自動擴展欄位，完整顯示數值，不受限。 Disbale path length limit after installed 假如裝 python 時沒勾選。安裝完畢後： modify the registry key: Windows Key + R, type “regedit” “Computer\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\FileSystem\\LongPathsEnabled” –\u003e set its value to 1 Web Crawling tags \u003clabel for=\"name\"\u003eName:\u003c/label\u003e \u003cinput type=\"text\" id=\"name\" name=\"name\"\u003e for=“xxx” \u003c–\u003e id=“xxx” ∴點擊上面Name:的字，連動到input框閃爍可輸入，不必一定要點擊input框 type=\"hidden\" : 僅給開發者使用/確認, or 加上時間戳記,檢核、防爬蟲等 網頁上有name=\"\"標籤的通常會被form送出 動態網頁 cookie Headers Status Code Rest API payload pyenv – Python version control ETL Poetry 其他自學 Hello 演算法\n~ 4.2 從位址計算公式的角度看，索引本質上是記憶體位址的偏移量。首個元素的位址偏移量是0 ，因此陣列首個元素的索引為0是合理的 由於陣列的長度是固定的，因此插入一個元素必定會導致陣列尾部元素“丟失” 刪除元素完成後，原先末尾的元素變得“無意義”，所以無須特意去修改 import numpy as np # 建立一固定長度的 numpy 陣列 arr = np.array([10, 20, 30, 40, 50]) print(\"原始陣列：\", arr) # 插入一個元素到index[2]，並移動後面的元素 # 手動模擬插入（ numpy 不像 list 可以直接 insert） arr[3:] = arr[2:-1] # 往後推一格 arr[2] = 99 # 插入新值 print(\"插入 99 後：\", arr) # 原本的 50 被擠掉了 # 刪除索引 1 的元素（把後面的往前搬） arr[1:-1] = arr[2:] print(\"刪除索引 1 後：\", arr) # 最後一格雖然還有值，但已經是「無意義」的資料 print(\"最尾端元素實際上已經沒用了：\", arr[-1]) 自架 GitHub + Hugo 靜態網站(https://ah-devworks.github.io//tags/hugo/)：\nUI(font, i18n/[language] yaml, favicon)、footer調整 技術彙整大致完成，剩餘額外補充待整理 網站尚有改善空間（Google Analytics、SEO…），但反正能用了，先暫時這樣堪用就好 實體書\n岡野原大輔 (2024). 精確掌握 AI 大趨勢！深度學習技術解密：日本 AI 神人，帶你正確學會從機器學習到生成式 AI 的核心基礎 (王心薇 \u0026 施威銘研究室, Trans.). 旗標. 讀到第二章 順便根據其中2.1節額外找 最小平方法(Least Squares)教學，雖然現在機器學習應該都不是用OLS了 Ceder, N. (2019). Python 技術者們：練功！老手帶路教你精通正宗 Python 程式 (張耀鴻, Trans.). 旗標. 中文是根據3rd Edition翻譯的，查了一下原作者Naomi Ceder今年有4th Edition 以英文4th edition為主、中文3rd Edtion為輔，讀到2.3.2 目前比較明顯差異是不再要求裝Anaconda之類的IDE，改用Google Colab hosted Jupyter Notebook放範例 Jupyter筆記本由兩種類型的單元格組成：文本單元格和代碼單元格 Udemy線上課程\nsmtplib 網路託管：PythonAnywhere smtplib的涉及個人信箱帳密，還是別放到網上比較好 其他一些無關且須重複執行的project倒是可以託管 進度嚴重落後，這周弄靜態網站花太多時間了🫠 ","description":"當周學習與生活雜記","tags":["learning","journal"],"title":"轉職路：AI養成班 Week 1.","uri":"/notes/2025/weekly_journal_202504_1/"},{"content":"自架網站筆記：使用Github + Hugo（上） 自架網站筆記：使用Github + Hugo（中） 更新靜態網站內容的方法 把新內容準備好（Markdown, image等檔案要放到Content-Repo裡各自對應的子資料夾），更新push。 git add . git commit -m \"新增文章：new-post\" git push origin main # 如果檔案較多較大，push後建議等一下 確認前一步驟content-repo已經上傳、更新好了之後，轉到Web-Repo 🌟Web-Repo 更新submodule: git submodule update --remote (可選) git status 檢查content-repo檔案有引入 git add [檔案] 後，可以先 hugo server 本地確認網站更新無誤；或直接 hugo 後把 public/ 內新檔覆蓋更新到母資料夾 git add . –\u003e git commit –\u003e git push origin main ，過幾分鐘 github 處理好，刷新網站即可。 可以到github 的web-repo檢查進度（如下圖✅｜萬一出現❌表示哪裡出了問題，要回頭檢查） 常見QA \u0026 Tips 【本機跑正常，GitHub Pages 樣式卻很簡陋】：一路做到PART III都沒問題，但實際網址連到的網頁外觀卻跟「hugo server」測試時「http://localhost:1313/…」的網頁明顯不同。 通常是baseURL沒設定好，或是publish的相對路徑、theme路徑或資源沒有正確被拷貝，導致Github Pages抓不到樣式 建議前述PART I的步驟7第二點再次確認：baseURL應該會是「https://[你的使用者名稱].github.io/」 確認hugo生成的public檔案必須全部拷貝到前一層資料夾（通常就是「/[你的使用者名稱].github.io」） 且每次修正後，都要重新hugo、update一次，讓Github Pagese更新（通常push後不會即時刷新，要等一下 –\u003e 可看github倉庫-Settings-Pages網站網址底下的小字「Last deployed by @user xxx minutes ago」來判斷刷新了沒） 有時候可能是theme本身的問題，假如theme本身有exampleSite（contents, layout等資料夾），建議可以複製回去、保持樣式，之後再來把範本內文取代掉 修改網站圖示(Favicon / Website Icon) 瀏覽網頁時，畫面上方網頁名稱的旁邊的那個小icon就是Favicon，預設會是主題自帶的icon。 製作 Favicon : 可以用 favicon.io 或 RealFaviconGenerator 之類的免費網站；懂PS的話也可以自己做，記得縮成512x512再轉成 .ico 或 .png 格式。 把Web-Repo/static/favicon 底下的檔案替換掉，重新hugo就行。 個人心得 拿關鍵字去google能找到很多「X分鐘快速架設網站」的文章或影片，但實際操作發現比較適合「就只是要個網站放些簡單文章/日記而已」的人，要多些功能的話，那複雜度就會開始上升了。 就我個人而言，首先構思網站的架構、層級劃分、文章類型就花了些時間； 挑theme又花了些時間，第一個挑的theme在clone時還碰到一堆缺少前製套件之類的奇怪狀況……； 再來又開始想「要把Content-Repo當成submodule？還是反過來把Web-Repo當成Content-Repo的sub？」之類，攸關彈性跟未來維護性等等的問題…… 明明簡單來說就只有兩個repo而已，花了快10小時，至少打掉重來三次……可能我是資質比較駑鈍的那種吧( 之後或許會不定期更新有關UI調整、自動部署（GitHub Actions/Hugo Deploy）、Project導入等等的筆記。 有任何疑問歡迎私信我 只是回信可能比較慢，請見諒。要是一直沒回覆，可以隔週再寄一次。\n— A.H.Dev-Works.\n參考資源 HUGO Docs Creating a Blog with Hugo and Github in 10 minutes –\u003e 注意這教的是把Web-Repo當成submodule的方法 【懶人包】使用 Hugo 5 分鐘內快速架設個人網站，號稱現在最快的自架網站方式 –\u003e 主要參考Hugo 從零開始: 用github pages 上傳靜態網站 Lightbi-Demo genryu-font ","description":"——自架靜態網站的過程紀錄．下篇——","tags":["hugo","blog","website"],"title":"自架網站筆記：使用Github + Hugo（下）","uri":"/post/2025/website/create_static_web_3/"},{"content":"【前一回】自架網站筆記：使用Github + Hugo（上） PART II : 設定內容倉庫（Contents-Repo） 本地另一個資料夾clone「放網站內容的repo（PART I步驟3建立的Contents-Repo）」 同樣初始化 touch README.md echo \"# [Contents-Repo]\" \u003e README.md git add README.md git commit -m \"Initial commit\" git push origin main 建立內容結構/資料夾 這裡可按照自己需要的層級或theme建議的層級來做 mkdir content cd content mkdir notes post 注意\r結構資料夾要包含Hugo在building網站時需要的各子資料夾\r通常是「contents」、「static」這兩個資料夾，但也不一定，建議翻查主題的Documents，有寫最好，沒寫的話就只能自己多hugo server測試幾次。\n建立一篇測試文章，如 echo -e \"+++\\ntitle = \\\"First Note\\\"\\ndate = 2025-04-05\\n+++\\n\\nThis is my first note.\" \u003e content/notes/first-note.md 或自己寫一個.md檔 push上去 注意這裡不要執行 hugo new site，Contents-Repo只負責網站上的內容檔案 [2025/04/11 更新] 6. 把Content-Repo的檔案（content/資料夾裡的.md文件 ＆ 可能有static/裡的圖片等額外檔案）確認都ok後，在這個資料夾先git add -\u003e commit -\u003e push 一次後，手動複製 content/ static/兩資料夾到 Web-Repo/ 底下，覆蓋更新原本Web-Repo/裡面的同名資料夾跟檔案 註: 原本submodule引入的方式太複雜，也容易出錯，反正兩個repo的檔案都在同一電腦本機，乾脆版本管理用各自的git，移動用手動的處理比較快。 再次 hugo server 測試，正確的話原本在Contents-Repo裡面的文章（步驟4做的）應該會顯示在網站對應的地方（如網站 [Notes] 標籤底下） 沒問題的話記得Web-repo 也要 push提交更改。 之後主要寫日記、文章、圖片都在Content-Repo進行，完成後git版本更新，再複製進Web-Repo/ 後 hugo，Web-Repo/也記得每次都要版本更新。這樣萬一哪次檔案不小心誤刪或蓋掉，還是可以回溯。 PART III : 部署網站到 GitHub Pages 生成靜態檔案：在Website-Repo用 hugo指令，在其下的 public/ 資料夾生成靜態網站檔案 把public/資料夾裡已生成的靜態網站全部檔案挪到前一層（手動把檔案複製貼上也可以） cp -r public/* . 提交 git add . git commit -m \"Generate static site\" git push origin main 再次add -\u003e commit -\u003e push 檢查網站是否正常顯示（github倉庫-Settings-Pages會顯示「Your site live at https://...」） 做到這，網站其實就算是架好了，其他細節跟QA放在下篇。 自架網站筆記：使用Github + Hugo（下） ","description":"——自架靜態網站的過程紀錄．中篇——","tags":["hugo","blog","website"],"title":"自架網站筆記：使用Github + Hugo（中）","uri":"/post/2025/website/create_static_web_2/"},{"content":" 第一篇文章，總之先簡單記錄這個靜態網站怎麼做的，不然大概隔幾天又忘光光。 原本只打算寫給自己複習用，所以有些我已經懂的部份（像是Git）寫比較簡單。如果有緣的你無意看到這篇，想看懂，但看不懂，歡迎私信我。 如果你/妳看到這篇文章的時候，網站已經有留言功能，也歡迎留言詢問。 PART 0 : 在動手之前 - 關於這個靜態網站 預先構想這個網站會由兩大部份（2 repositories）構成：\nWebsite-Repo：負責靜態網站呈現（用 Hugo build 出來的 HTML/CSS/JS）。 Contents-Repo：放原始內容（markdown，如 content/notes、content/diary）。 未來更新內容主要會在 Contents-Repo，然後將生成的網站部署到 Website-Repo。 也會將其他專案 repo（像 side projects）整合進這個 Hugo 網站。 行有餘力再多加上其他功能（Google Analytics, SEO, comments） PART I : 基礎設定 已經有github帳號 Windows winget install Hugo.Hugo.Extended 安裝Hugo（建議安裝 Hugo Extended版本，方便後續自訂模板樣式） github新建兩個repo：一個放內容（Contents-Repo），一個負責網站本身(Website-Repo. – ex.AH-DevWorks.github.io)，分別clone到本地的資料夾（這時兩個倉庫都還是空的，正常） 建議\r上述操作需要有「git」以及「github」的基礎理解，如果不懂的話，請先關鍵字google或問AI。\r初始化git分支 touch README.md echo \"# [Website-Repo]\" \u003e README.md git add README.md git commit -m \"Initial commit\" git push origin main 本地clone放網站內容的repo，hugo new site . 設在母資料夾較佳，建議別再額外新增如 hugo new site [MySite etc.]，否則後續要每次都手動挪動/public或額外設定自動腳本，會很麻煩。 若母資料夾已有內容（如README.md），則用 hugo new site . --force 等Hugo自動建立好內容後，cd到themes資料夾；挑個Hugo的theme，照著說明來裝（例如clone 到 themes資料夾，或用Git submodules處理） {{/* \u003c info_cards header=“suggest” title=“這裡以Lightbi為例” content=“https://themes.gohugo.io/themes/lightbi-hugo/\" \u003e */}} 把這個theme設成預設： 回到步驟5建立好的母資料夾，vi hugo.toml 編輯toml內容： A. [baseURL]改成步驟3負責網站本身的repo網址(通常是https://[user_name].github.io/)；B. [title]改隨意（會顯示往站上）；C. [theme]改成前幾步驟挑選的 關於hugo.toml參數\r參數與功能跟主題密切相關，建議先翻看主題給的Documents。以Lightbi為例，參數的說明就放在Demo網站的文章裡：https://lightbi-hugo-theme.netlify.app/en/post/2020/parameters/\r初步測試：hugo server，應該會有空白模板或theme預設範本網頁 有些theme偏舊，這步會出現問題，直接換一個theme比較省事 正確的話bash或cmd會顯示網站生成的頁數、靜態檔案數量等資訊 找到其中Web Server is available at http://localhost:1313/...這行，貼到瀏覽器，有出現看起來像網頁的樣子就對 確認ok後要再提交一次更改到github git add . git commit -m \"Set up website with theme\" git push origin main 【下一回】自架網站筆記：使用Github + Hugo（中） ","description":"——自架靜態網站的過程紀錄．上篇——","tags":["hugo","blog","website"],"title":"自架網站筆記：使用Github + Hugo（上）","uri":"/post/2025/website/create_static_web_1/"}]
