[{"content":"A clean and reproducible pipeline for YOLO training, validation, testing and prediction using CLI and VSCode DevContainers.\n目錄 Table of Contents 動機與用途 | Why this setup? 執行方式 | How to Run 1. Clone 專案 2-1. 使用 VSCode DevContainer (推薦) 2-2. 開啟後直接使用 .py 執行 CLI 模組設計 | CLI Script Design 常見調整點 | Customizable Elements 心得與備忘 | Notes \u0026 Learnings 動機與用途 | Why this setup? 原本是轉職班小組專題的模型訓練核心程式，經過不少 Trial and Error，到中期才比較完整。整理、分享出來，當作一個歷程紀錄 程式本身提供一套 YOLO（v11、v12為主）的物件偵測流程（Train-Valid-Test） 以 notebook 為主要使用介面，支援互動式開發與視覺化 另提供 Python CLI 腳本，用於簡化批次執行或伺服器自動化 使用 Docker 容器封裝整體環境，確保部署時對跨平台／系統的一致性 對應訓練、驗證、測試、推論流程皆已封裝為獨立模組，可彈性組合使用 執行方式 | How to Run 1. Clone 專案 git clone https://github.com/AH-DevWorks/yolo-devcontainer.git cd yolo-devcontainer **預訓練權重(.pt檔)**可到 Ultralytics 網站 下載 v12 v11 p.s. 權重有分大小（n, s, m, l, x），建議衡量本機性能做挑選 個人使用 32GB RAM | RTX 4070(12G)，頂多到l，x 會直接 OOM 爆記憶體 2-1. 使用 VSCode DevContainer (推薦) # 開啟 VSCode 後選擇 F1 → Dev Containers: Reopen in Container 2-2. 開啟後直接使用 .py 執行 python train.py --model models/yolo12n.pt --data data.yaml python valid.py --model runs/train/weights/best.pt python test.py --model runs/train/weights/best.pt python predict.py --model runs/train/weights/best.pt --source dataset/images/test CLI 模組設計 | CLI Script Design 所有 CLI script 使用統一的 argparse 介面（定義於 _common.py），並在各執行檔中加上必要擴充參數。 例如 train.py 支援以下主要參數：\n--model 初始模型權重路徑 (e.g. yolov8n.pt) --data 訓練資料 yaml 設定檔 --epochs 訓練輪數 --cos_lr 是否使用 cosine lr decay --multi_scale 是否啟用多尺度訓練 --optimizer 選擇 Optimizer (e.g. SGD, AdamW) 常見調整點 | Customizable Elements 資料集路徑：預設為 ./dataset/ Dataset 除了自己準備、標記以外，也可到 cityscapes、Roboflow 等網站先下載已標記好的來嘗試訓練 關於如何準備＆標記資料集，可能改天會再發一篇簡單的心得文章 Ultralytics提供的預訓練權重（如yolov11m.pt、yolov12l.pt）就是用COCO的來訓練，縱使不做遷移學習，也可以有基本幾種類別辨識。如以下影片的最後5秒就是直接拿yolo11來偵測影片，能抓到「person」、「umbrella」、「bicycle」等類別 關於這影片可參考我另一篇 OpenCV文章 文末另有我小組專案最後的成果（藥品辨識模型 with YOLOv12）示意圖供參 config 檔案：data.yaml 與模型 *.yaml 可自己隨資料集替換 超參數調整：可直接修改 train.py 呼叫區或透過命令列參數覆寫 Notebook 配合：與 notebook 訓練結果 (如 best.pt) 可相互參考，不衝突 心得與備忘 | Notes \u0026 Learnings 使用 DevContainer + Dockerfile，能最小化環境問題，並順利支援 CUDA GPU 訓練 [！]但整個專案過程裡曾經偶爾出現幾次意外的Error如「‘AAttn’ object has no attribute ‘qkv’…」、「Can’t get attribute ‘A2C2f’ on \u003cmodule ‘ultralytics.nn.modules.block’…\u003e」—\u003e 爬文說只要更新ultralytics套件即可（須注意numpy版本應\u003c2才不衝突）；目前Dockerfile等有做預防措施，但不保證一定不會出現 CLI 方式可輕鬆整合自動化腳本，部署至伺服器或嵌入設備 Ultralytics 的 YOLO API 本身支援 .train(), .val(), .predict() 等方法 實測YOLOv12 Fine-tune 藥丸辨識（50種左右）每一Class張數約100張左右（使用Copy-Paste Method），Augmentations兩倍，總training set張數約11K；訓練150epoch、batch=8、開啟cos_lr跟multi_scl後成效佳。Inference 結果如下圖 關於 Copy-Paste Method，改天可能會再寫一篇簡介 GitHub Repo: yolo-devcontainer\nReferences: Ultralytics\n","description":"使用 Python CLI 與 DevContainer 建立可重複訓練與推論的 YOLOv12/v11 工程環境","tags":["yolo","object detection","cli","docker"],"title":"YOLOv12/v11 模型訓練與推論","uri":"/post/2025/ai/yolo-devcontainer_20250729/"},{"content":"A visual and technical showcase of video transformation effects using OpenCV \u0026 DL Models.\n目錄 Table of Contents 為什麼做這個？ 安裝與執行方式 架構設計 功能與技術細節 我學到的 技術資源與參考 為什麼做這個？ | Why build this? 學了些 OpenCV 知識，就來試試不靠 AE 之類的剪輯軟體，用程式＋模組做出各種影片效果。 因為好玩 順便交作業 安裝與執行方式 1. Clone 專案 git clone https://github.com/AH-DevWorks/vid-polymorph.git cd vid-polymorph-main 2. 使用 DevContainer (推薦) 專案內建 .devcontainer/，可直接透過 VSCode Remote Container 啟動 GPU 開發環境。\n# [vscode] F1 → Dev Containers: Reopen in Container # 初次開啟時選擇： Reopen in Container 或者也可手動 build Docker：\ndocker build -t vidpolymorph . docker run --gpus all -v ${PWD}:/workspace -w /workspace vidpolymorph python3 vid-poly-morph.py 3. 或使用 Jupyter Notebook # 開啟 notebook jupyter notebook # 選擇 `vid-poly-morph.ipynb` 架構設計 影片會依時間序列，套用多種特效，並即時疊加縮圖與提示字樣。整體流程如下：\n→ 逐一輸入影片(如video/123.mp4)的影格 → 動態放大至 1.5x → 套用對應特效（時間排程） → 疊加縮圖與狀態文字 → 寫入 video/123_output.mp4 時間上的「特效排程」可自訂比例，例如 [3] 4 in 1 + Flip 佔整段影片的 10%。\n每個效果都對應一個模組函式，如：\n(0.10, \"[4] 4 in 1 + Flip\", lambda canvas, scaled, idx: four_in_one( canvas, scaled, effects=[ None, lambda x: cv2.flip(x, 1), lambda x: cv2.flip(x, 0), lambda x: cv2.flip(x, -1) ])), 藉此維持主邏輯簡潔，且讓特效模組易於擴充或重組。\n功能與技術細節 影片中的特效依照時間順序依序展示以下處理手法：\n效果編號 ID 特效說明 Effect [0] 1.0 → 1.5 倍線性放大 [1] 維持 1.5 倍尺寸 [2] 旋轉 1080 度（共 3 圈） [3] 四分割遮罩（圓、矩形、橢圓、三角形）/ 4-in-1 masking [4] 四分割翻轉效果 / 4-in-1 flip effects [5] 16-in-1 彩色映射顯示 / 16-in-1 colormap panel [6] 邊緣偵測 (Sobel/Canny/Laplacian) [7] 高斯差分 / Difference of Gaussian (DoG) [8] 形態學處理 / Morphological operations (Dilation, Opening, Gradient) [9] 特徵點偵測與描述 / Feature detection \u0026 descriptors (SIFT, SuperPoint, ORB) [10-1] RetinaFace 偵測 + 馬賽克 [10-2] 純 RetinaFace 人臉偵測 [11] YOLOv11 物件偵測 我學到的 如何安排、控制特效「時長」與「順序」 熟悉程式視覺特效模組化與可擴充性 啟用 GPU-ready Docker 容器（TensorFlow 2.15 + OpenCV） 附錄：技術資源與參考 + OpenCV + RetinaFace — 高準確率人臉偵測器 → High-accuracy face detector https://github.com/serengil/retinaface + SuperPoint — 自監督式特徵點偵測與描述子 → Self-supervised keypoint detector \u0026 descriptor https://github.com/rpautrat/SuperPoint + YOLOv11（官方預訓練版本）— https://docs.ultralytics.com/tasks/detect/ + tqdm / NumPy / matplotlib 等輔助工具 YOLO 模型\r假如對於自己訓練 YOLO 模型有興趣，可以看我的另一篇文章：https://ah-devworks.github.io/post/2025/ai/yolo-devcontainer_20250729/\r若有興趣深入本專案內各項處理邏輯， 可至 GitHub Repo 檢視 utils/ 中各個模組檔案與主程式流程。\nAnother Demo video on YouTube: Source video: 容疑者Xの献身 (Suspect X, 2008)\n","description":"試著不靠 AE 之類的剪輯軟體，用程式＋模組做出各種影片效果","tags":["opencv","blog","yolo","ai"],"title":"Vid-PolyMorph — 多種視覺特效的影片處理","uri":"/post/2025/ai/vid-polymorph_20250722/"},{"content":"batch-openai-txt2zh (非同步 .txt 檔批次翻譯器) 透過 OpenAI 模型的 Batch API ，大量批次把你的文件上傳給AI翻譯。\n雖然標題是寫翻譯「小說」，但其實任何文件——只要能轉成.txt文字檔——都能翻譯\n和前一篇[同步式翻譯]方法最大的不同在於「程式開起來跑一次start後，檔案就會上傳給AI處理，本機程式可以關掉，過一陣子再重啟確認翻譯完成了沒」，程式/網路/電腦都不用一直開著 檔案連結↓ https://github.com/AH-DevWorks/batch-openai-txt2zh\n可以直接點進上面連結，按綠色的「\u003c \u003e Code」按鈕 → 「Download ZIP」→ 解壓縮後照著網頁上的說明或「readme.md」文件進行 使用教學 過程大部份內容都跟前一篇[同步式]的類似，只有啟動的指令稍微不同\n檔案連結 點進上面連結，按綠色的「\u003c \u003e Code」按鈕 → 「Download ZIP」→ 解壓縮（包含「batch-openai-txt2zh」這個最外層資料夾） 解壓縮完的資料夾裡面應該至少會有這些項目： batch-openai-txt2zh/ ├── main.py # 程式進入點 ├── batch_handler.py # 建立＆確認batch；任務進度確認 ├── check_limits.py # 估算tokens總數 ├── parse_output.py # 解析 .jsonl ，將翻譯完畢之內容儲存為 .txt ├── .env # API金鑰所在位置 ├── input_files/ # ***【請把你要翻譯的 .txt 檔案放入此資料夾】*** ├── output_files/ │ └── translated_txts/ # 翻譯完畢的檔案位於此處 ├── requirements.txt # 依賴套件列表 ├── batch_files/ # 存放 .jsonl 酬載(payloads) ├── batch_state/ # 留存近期batch_id ├── readme.md # 【使用說明】 ├── finished_files/ # 存放已完成任務之原始文檔 └── sample_docs/ # 範例文件 安裝必要套件\n電腦內請先安裝 python ，可到Python官方網站下載 建議使用 python 3.10 以上的版本。照著程式安裝的步驟，全點下一步就能裝好 安裝本專案所需的 Python 套件 [Windows] 在前一步驟解壓縮好的資料夾裡面（main.py所在的資料夾裡）按住鍵盤 Shift 鍵 + 點滑鼠右鍵 → 選擇「在這裡開啟 PowerShell 視窗」或「在終端中開啟 / 在此處開啟命令提示字元」 [Mac] 開啟 Finder，進入main.py所在的資料夾 → 右鍵 → 點選「服務」→「在終端機中開啟」 輸入或複製貼上以下指令： pip install -r requirements.txt 視窗會跑一堆像是下載＆安裝的資訊出來，放著等全都裝好，視窗沒再動之後就可以關掉 設定 API 金鑰\n用記事本等軟體開啟 .env.example 檔案，修改其中 API_KEY 欄位，填入你自己的 OpenAI API Key(金鑰)，並且將檔案重新命名為「.env」 OpenAI API 金鑰申請: 進入 OpenAI Platform，註冊/登入，資料填一填就能 Generate API Key 通常需要先跟OpenAI買一些credits才能用，我自己是先儲值5美金，再把\"Billing - Auto recharge\"這個功能打開，credit不夠的時候會自動加值，翻譯就不會突然中斷 關於如何取得API Key的過程不贅述，可自行搜尋或參考How To Get Your OpenAI / ChatGPT API Key (2025)等教學 回到步驟1解壓縮完的資料夾，找到 [input_files] 資料夾，把要翻譯的檔案全放進資料夾裡\n支援格式：純文字（.txt） 執行主程式：在main.py所在的資料夾內點選滑鼠右鍵 —\u003e 選擇「在終端中開啟」 —\u003e 輸入 python main.py start -\u003e 順利的話就會看到視窗跑出「[✅] 上傳完成。檔案 ID:xxxxx」的訊息，表示已經上傳給AI開始翻譯了\n這時就可以放心把這個執行中的視窗關閉，或是要斷網、關機都可以，檔案是在 OpenAI 那邊處理的 耗費的時間是依照原文字數＆文件數量的多寡而定 過程中可以隨時打開程式來確認進度：在main.py所在的資料夾內點選滑鼠右鍵 —\u003e 選擇「在終端中開啟」 —\u003e 輸入 python main.py status 確認進度＆下載完成檔：在main.py所在的資料夾內點選滑鼠右鍵 —\u003e 選擇「在終端中開啟」 —\u003e 輸入 python main.py status\n如果都翻譯完成，應該會跳出一堆勾勾（✅）符號的訊息，最後一則是「[✅] 翻譯檔案整理完畢：...」，表示成功 點進 [output_files]–\u003e[translated_txts] 資料夾，裡面就是翻譯好的各檔案；原始原文txt檔則會挪到 [finished_files] 資料夾裡 額外補充 — 操作指令集 動作 指令 說明 預估 Token 使用量 python main.py check-limit 送出前先檢查是否超量 開始翻譯 python main.py start 上傳 JSONL → 建立 Batch 任務 查詢進度/下載結果 python main.py status 進度查詢；若完成，則自動下載檔案 取消目前批次 python main.py cancel 向 OpenAI API 發送取消請求 簡單說明如上，假如有任何疑問，歡迎發E-mail給我 或到上面檔案連結裡的 github add new issue\n參考資源 OpenAI Batch API Documentation p.s. 其實用n8n或其他AI Agent八成更快，但手刻的成就感總是高一點 ","description":"Batch API工具，用 OpenAI 的AI模型(o4-mini)批次同時處理多筆 .txt 檔案翻譯","tags":["blog","API","OpenAI","model"],"title":"用 OpenAI GPT Batch API 大量翻譯小說 （非同步式）","uri":"/post/2025/api/batch-openai-txt2zh_202505/"},{"content":"\nComparison - Before-and-After Text\nOpenAi Doc Translator (OpenAI 文件翻譯器) 透過 OpenAI 模型 API ，快速翻譯你自己的文件。\n雖然標題是寫翻譯「小說」，但其實任何文件——只要能轉成.txt文字檔——都能翻譯\n檔案連結↓ https://github.com/AH-DevWorks/synchronous-openai-doc-translator\n可以直接點進上面連結，按綠色的「\u003c \u003e Code」按鈕 → 「Download ZIP」→ 解壓縮後照著網頁上的說明或「readme.md」文件進行 這是個人Side Project的副產物，核心是呼叫OpenAI的API，搭配簡單的前處理（原文段落自動拆分）＆循環串接，達到「翻譯文本連貫性」的效果 內容儘量寫得簡單，不懂程式的人大概也能照著操作，拿自己的OpenAI金鑰來翻譯文件 特色 從原文前處理到譯文串接都是在本機程式上進行，只有「翻譯」階段的文本才會連網傳到 OpenAI Model上面進行AI翻譯 最大好處就是只會經過 OpenAI ，不會再有其他第三方服務拿到你的資料或權限 用你自己的API，除了你自己以外，也不會有其他人知道你翻譯了些什麼 P.S. OpenAI API 服務的帳號後台 https://platform.openai.com/ 上面也提供使用者手動確認歷史紀錄、Credits用量、自動Credits儲值等功能 當然，操作上肯定沒有其他像是「沉浸式翻譯」之類的網路外掛套件來得方便簡單，功能也沒那麼豐富 懂程式的人也可以拿這個程式當基底，自己擴展像是讀取圖片、單純聊天對話、摘要PDF等功能，反正只要OpenAI有給API的都能擴展 OpenAi Doc Translator 使用教學 基本就只是照搬readme.md內容，多加上幾張示意圖\n檔案連結 點進上面連結，按綠色的「\u003c \u003e Code」按鈕 → 「Download ZIP」→ 解壓縮（包含「synchronous-openai-doc-translator-main」這個最外層資料夾） 解壓縮完的資料夾裡面應該至少會有這些項目： synchronous-openai-doc-translator-main/ ├── main.py # 程式進入點 ├── files_handler.py # 處理檔案（讀取／儲存） ├── text_segmenter.py # 拆分原文txt檔成為段落 ├── api_translator.py # 呼叫OpenAI API處理翻譯 ├── .env # API金鑰所在位置 ├── input_files/ # *** 把要翻譯的 .txt 檔放進這裡 *** ├── output_files/ # 翻譯完畢的檔案會出現在這個資料夾 ├── requirements.txt # 依賴套件列表 ├── README.md # 【使用說明】 └── sample_docs/ # 範例文件 安裝必要套件\n電腦內請先安裝 python ，可到Python官方網站下載 建議使用 python 3.10 以上的版本。照著程式安裝的步驟，全點下一步就能裝好 安裝本專案所需的 Python 套件 [Windows] 在前一步驟解壓縮好的資料夾裡面（main.py所在的資料夾裡）按住鍵盤 Shift 鍵 + 點滑鼠右鍵 → 選擇「在這裡開啟 PowerShell 視窗」或「在終端中開啟 / 在此處開啟命令提示字元」 [Mac] 開啟 Finder，進入main.py所在的資料夾 → 右鍵 → 點選「服務」→「在終端機中開啟」 輸入或複製貼上以下指令： pip install -r requirements.txt 視窗會跑一堆像是下載＆安裝的資訊出來，放著等全都裝好，視窗沒再動之後就可以關掉 設定 API 金鑰\n用記事本等軟體開啟 .env.example 檔案，修改其中 API_KEY 欄位，填入你自己的 OpenAI API Key(金鑰)，並且將檔案重新命名為「.env」 OpenAI API 金鑰申請: 進入 OpenAI Platform，註冊/登入，資料填一填就能 Generate API Key 通常需要先跟OpenAI買一些credits才能用，我自己是先儲值5美金，再把\"Billing - Auto recharge\"這個功能打開，credit不夠的時候會自動加值，翻譯就不會突然中斷 關於如何取得API Key的過程不贅述，可自行搜尋或參考How To Get Your OpenAI / ChatGPT API Key (2025)等教學 回到步驟1解壓縮完的資料夾，找到 [input_files] 資料夾，把要翻譯的檔案全放進資料夾裡\n支援格式：純文字（.txt） 執行主程式：在main.py所在的資料夾內點選滑鼠右鍵 —\u003e 選擇「在終端中開啟」 —\u003e 輸入 python main.py -\u003e 順利的話就會看到視窗開始跑進度條，表示已經開始翻譯了\n記得「不能」把這個執行中的視窗關閉（可以縮小或放到畫面旁邊），也儘量不要斷網 耗費的時間是依照原文字數＆文件數量的多寡而定，可參考底下我的簡單估計 視窗顯示都翻譯完畢後，可以點進 [output_files] 資料夾，裡面以「[Translated]…」開頭的就是翻譯好的檔案了\n額外補充 根據個人經驗，翻譯一本原文（英文）字數 95,000 左右的小說，大約需要 40～60 分鐘\n但實際 AI 在「讀」文字的時候，看的不是「原文有幾個字」，而是會把字句拆成 Token (符記)：一個英文單詞如果是由比較多個字母組成，就可能被拆成2～3個token；中文字則通常是一個字一個token。如下面示意的： Tokenizer | OpenAI Platform: 把原文複製貼上，就能推估有多少tokens OpenAI API是以token來計價，以這個程式呼叫的「gpt-4.1-mini」來說：\nInput Tokens(輸入的tokens，也就是每次翻譯的原文＆程式告訴AI要做翻譯的中文指令)：每一百萬個tokens=美金$0.40元 Output Tokens(輸出的tokens，也就是AI翻譯好、回傳給我們的中文內容)：每一百萬個tokens=美金$1.60元 從上面就可以看出，「用程式來跟AI模型交流」的方式，如果不是用量很兇，算起來會比直接登入ChatGPT、訂閱Plus等方案來得划算\n但有一點要注意：這個 OpenAi Doc Translator 程式原始目標是「小說的翻譯」，「小說」非常重視邏輯、語氣、人名的前後一致，所以程式裡用了一種「能讓翻譯連貫」的方法，而這個方法會讓 Input Tokens 提昇\n這裡不講得太複雜，只說結論：如果你要翻譯的是「超長篇鉅作（比如魔戒三部曲）」，建議不要一次就把整本將近500頁原文、快要20萬字的小說放進 [input_files] 資料夾裡 ==\u003e 但你可以把每一本再拆成2～3個txt檔（像是按照章節去拆，每一份txt檔案裡面包含3～5章之類的）。例如原本魔戒有3大本txt檔，拆好之後變成12個分章的txt檔案，這時後再一起放進 [input_files] ，總tokens數量在AI看來就會比較少，簡單來說就是比較省錢 要是擔心這樣拆分，人名/地名會不連貫的話，可以預先在每一份小txt檔內文的最前面，自己手動加上「對照表」、告訴AI： ☆【人名/地名對照表，請按照對照表來翻譯】☆ Frodo Baggins：佛羅多·巴金斯 Gandalf：甘道夫 Aragorn：亞拉岡 Legolas：勒苟拉斯 Gollum：咕嚕 ☆【以上是人名/地名對照表】☆ The Fellowship of the Ring J.R.R. Tolkien Chapter I: A Long-expected Party When Mr. Bilbo Baggins of Bag End announced that he would shortly be celebrating his eleventy-first birthday with a party of special magnificence, there was much talk and excitement in Hobbiton. Bilbo was very rich and very... 簡單說明如上，假如有任何疑問，歡迎發E-mail給我 或到上面檔案連結裡的 github add new issue\n參考資源 OpenAI Responses API Documentation Models Tokenizer ","description":"簡單的API工具，用 OpenAI 的AI模型(gpt-4.1)來把 .txt 檔案翻譯成繁體中文","tags":["blog","API","OpenAI","model"],"title":"用 OpenAI GPT API 翻譯小說 （同步式）","uri":"/post/2025/api/synchronous-openai-doc-translator_202505/"},{"content":"第三週：4/22、4/24～4/28 Xpark - “Tomorin” the King Penguin\nMySQL DDL, DML(/DQL), TCL, E-R Model(UML) MongoDB NoSQL Commands: show, insert, find, delete, etc. _id Python NumPy, Pandas, Matplotlib Class Variable, Instance Variable 自補充 SQL CTE(Common Table Expression) Window Function 其他自學 實體書\n岡野原大輔 (2024). 精確掌握 AI 大趨勢！深度學習技術解密：日本 AI 神人，帶你正確學會從機器學習到生成式 AI 的核心基礎 (王心薇 \u0026 施威銘研究室, Trans.). 旗標. Udemy線上課程\nAPI Keys, Authentication, Environment Variables, Sending SMS pycharm – Terminal–\u003e dir Env: $env:[var_NAME]=\"[var_CONTENT]\" call in program: var = os.environ.get(\"var_NAME\") 均一教育平台: KNN, K-means\n李宏毅【生成式AI導論 2024】\n李宏毅【機器學習2021】\nBro Code - MySQL Full Course for free 🐬\nLeetCode 【Algorithms】： 1.Two Sum | 2.Add Two Numbers | 3.Longest Substring Without Repeating Characters Side Project 主題：[AI相關]（名稱與具體內容暫不揭露） 進度：[██░░░░░░░░░░░░░░░░░░] 10% [✔] 初步規劃與構想 [✔] 選定資料來源 [✔] 完成並執行腳本（資料抓取/預處理） [◎] 進行中：進一步 Data Cleaning [　] … ","description":"當周學習與生活雜記","tags":["learning","journal"],"title":"轉職路：AI養成班 Week 3.","uri":"/notes/2025/weekly_journal_202504_3/"},{"content":"❌ 所有的 DML 都可以在 View 上操作 Simple View ==\u003e 滿足下列條件，才可以用DML 只有一個Base Table，沒有JOIN 沒有使用Function(SUM, AVG等)或分組(GROUP BY, DISTINCT 等) Updateable 可更新 Complex View NO DML ✅ Foreign Key 可由多個欄位組成 可以由多個欄位組成複合外鍵（Composite Foreign Key），只要這些欄位對應參照表的一組 PK 或 UK 即可 p.s. FK可以是NULL空值 DDL (Data Definition Language) CREATE, DROP, ALTER, RENAME, TRUNCATE DML (Data Manipulation Language) INSERT, UPDATE, DELETE, *SELECT *註: 亦有分類將 SELECT 單獨歸類為 DQL (Data Query Language) DCL (Data Control Language) GRANT, REVOKE TCL (Transaction Control Language) COMMIT, ROLLBACK, SAVEPOINT SQL 語法順序 ≠ 實際執行順序 語法順序ex. SELECT name, COUNT(*) as order_count FROM orders WHERE status = 'completed' GROUP BY name HAVING COUNT(*) \u003e 5 ORDER BY order_count DESC LIMIT 10; 實際執行順序 Logical Execution Order FROM -- 1. WHERE -- 2. GROUP BY -- 3. HAVING -- 4. SELECT -- 5.※ ORDER BY -- 6.所以ORDER BY 裡可用 SELECT 定義的 column別名 LIMIT -- 7. ⚠ MySQL 實作上會提前解析 SELECT 子句中的別名：可看成SELECT在第3順位 SELECT employee_name Name, department_id D_ID, MAX(salary) M_sal FROM employees WHERE hiredate \u003e '2011-02-01' GROUP BY Name, D_ID -- 可以用別名Name, D_ID HAVING M_sal \u003e 1600 -- 可以用別名 m_sal ORDER BY Name LIMIT 3; ''' ↓ SELECT 提前解析 ''' FROM WHERE SELECT -- \u003c-- ※ GROUP BY -- 以下幾個都可用column別名 HAVING ORDER BY LIMIT ","description":"重點觀念複習","tags":["learning","sql"],"title":"SQL Test - Review","uri":"/notes/2025/sql_review_20250504/"},{"content":" 上課老師說時間不夠，這兩項目講不到，就當作延伸。\n自學後做了些紀錄。\n目錄 CTE(Common Table Expression) Window Function CTE(Common Table Expression) 一般資料表運算式 說明 CTE是 SQL 裡的一種臨時結果集 「暫存」且「具名」的結果集合，透過AS關鍵字將查詢結果暫時儲存 創建後可在SELECT、INSERT、UPDATE、DELETE等處使用，讓查詢邏輯更清晰、可讀性更高 【基本語法】 WITH CTE名稱 AS ( SELECT 查詢語句 ) SELECT * FROM CTE名稱; 【基本範例1：查各部門平均薪資，按部門分類】 -- CTE WITH cte_name AS ( SELECT Department, AVG(Salary) AS AvgSalary FROM Employees GROUP BY Department ) SELECT * FROM cte_name; -- 使用上面創的CTE 【基本範例2：查出薪資高於全體平均薪資的員工】 WITH avg_salary AS ( SELECT AVG(sal) AS avg_sal FROM emp ) SELECT e.* FROM employees e CROSS JOIN avg_salary a WHERE e.salary \u003e a.avg_sal; CTE 用於 Tree Recursion 樹狀結構遞迴 CTE適用在處理遞迴資料結構，或整理複雜查詢邏輯 【範例：查出公司內部從老闆開始，往下每層的隸屬關係】 WITH RECURSIVE employee_hierarchy AS ( -- 單只寫 NULL 會被推斷成字元長度太短，所以明確指定型別: CONVERT(NULL, CHAR(25)) -- 這裡CONVERT()預設型別不能使用 VARCHAR --\u003e MySQL本身的限制，能用固定size的CHAR，但可變長度的VARCHAR不能處理 -- 加level只是方便把各員工所屬層級看得更清楚 SELECT id, name, manager_id, CAST(NULL AS CHAR(25)) AS manager_name, 1 AS level FROM employees WHERE manager_id IS NULL -- 初始層級：BOSS (沒有上級mgr(manager)) UNION ALL -- 遞迴層級：找出每一層的下屬 SELECT e.id, e.name, e.manager_id, h.name AS manager_name, h.level + 1 FROM employees e JOIN employee_hierarchy h ON e.manager_id = h.id ) SELECT * FROM employee_hierarchy ORDER BY level; CTE vs. Subquery 項目 CTE（Common Table Expression） Subquery（子查詢） 語法位置 使用 WITH 開頭，通常在主查詢之前 可以寫在 FROM、WHERE、SELECT 等處 可重用性 定義好的CTE可在同一個查詢中重複使用 無法重複使用；每次都要寫完整的查詢內容 可讀性 較佳，易於拆解複雜邏輯 當巢狀太深時，可讀性較差 支援遞迴 ✅ 可使用 WITH RECURSIVE ❌ 不支援遞迴 效能差異 理論上差不多，實際依資料庫優化器與查詢內容而異 一般查詢引擎也會優化 subquery 為臨時表格 參考資料：SQL語法 - CTE 一般資料表運算式（COMMON TABLE EXPRESSION） Window Function 窗口函數／視窗函數 說明 SQL 中的一種分析工具，可以針對每一列資料，計算其在某個「資料視窗（window）」中的統計結果，而不會將資料壓縮成單一列 「在資料列上滑動『一個局部範圍』進行計算」（e.g.每個部門的薪資排名、累積總和等） 【基本語法】 \u003cWindow_Function_name\u003e(欄位) OVER ( [PARTITION BY 分組欄位] [ORDER BY 排序欄位] [ROWS BETWEEN ...] ) PARTITION BY: 把資料按照某欄位分組形成多個「window」，然後在每一組中各自執行視窗函數邏輯 跟GROUP BY不同：GROUP BY後資料筆數通常會減少；PARTITION BY後資料筆數不變、結合原本欄位。 GROUP BY不能搭配Window Function PARTITION BY 可以省略 –\u003e 表示「整張table為一個視窗」，window function 會對所有資料列共同計算（如下聚合型的範例2） 常見的 Window Function Aggregate-style 聚合型：SUM(), COUNT(), AVG(), MAX(), MIN() Ranking 排序型：ROW_NUMBER(), RANK(), DENSE_RANK() Value Offset 位移型：LAG(), LEAD(), FIRST_VALUE(), LAST_VALUE() 聚合型 Window Function 在一般查詢 / GROUP BY 語境下也可用，但在 Window Function語境下，不會壓縮rows\n【範例1：加總每個部門的銷售總額（每列都顯示）】 SELECT employee_id, department, amount, SUM(amount) OVER (PARTITION BY department) AS total_in_dept FROM sales; -- 顯示每筆銷售及所在部門的總銷售金額 【範例2：排序各員工薪資佔人事總成本的百分比】 -- 省略PARTITION BY 的用法 SELECT id, name, job, salary, CONCAT(ROUND(salary/SUM(salary) OVER() * 100, 2), '%') AS personnel_costs_percent FROM employee ORDER BY salary DESC; -- 高到低排序 排序型 Window Function ROW_NUMBER(): 給每一行一個不重複的序號，且就算指定比對的數值一樣（如score都=1000），仍會排出高低次序。\nSELECT *, ROW_NUMBER() OVER (ORDER BY salary DESC) AS sal_row_rank FROM employee; 所以各 row 再多加明確排序欄位（如 ROW_NUMBER() OVER (ORDER BY SALARY DESC, ID ASC)）比較好 ==\u003e 避免同值之間「非確定性」（nondeterministic）的先後順序。 RANK(): 相較於ROW_NUMBER()，RANK()會把同數值的項目給予同編號，且若序號重複，往後序號會跳號 (ex. 1,2,2,4,5,…)\nSELECT *, RANK() OVER (ORDER BY salary DESC) AS sal_row_rank FROM employee; DENSE_RANK(): 類似RANK()，但重複不跳號 (ex. 1,2,2,3,4,…)\nSELECT *, DENSE_RANK() OVER (ORDER BY salary DESC) AS sal_row_rank FROM employee; NTILE(n): （或歸類在分析型）分位排序，把資料依照參數(正整數n)拆成n組(tiles)，每組儘量平均放入數量儘量相同的資料、且依序給予序號 常用在需要分等第/區間的情況 若data總筆數不能被n整除，前幾組會多一筆資料 -- 將所有員工依照薪水高到低排序，分成4組，並且標示每筆屬於哪一組 SELECT employee_id, salary, NTILE(4) OVER (ORDER BY salary DESC) AS salary_quartile FROM employee; 位移型 Window Function 這類函數會取排序之後的上一筆、下一筆或特定位置的值，方便做時間序列比較、成長率分析等\n透過 SELF JOIN 也能達成類似結果（但外觀看起來不太一樣）\nLAG() OVER (PARTITION BY ... ORDER BY ...)：把資料往後移動，用來與上一列資料比較 LAG( [ 要位移的欄位 ], [ 位移列數 ], [ 沒資料時的預設值 ] ) LEAD() OVER (PARTITION BY ... ORDER BY ...): 把資料往前移動，用來與下一列資料比較 FIRST_VALUE(column_name) OVER (PARTITION BY ... ORDER BY ...)：查詢該分區第一列資料 LAST_VALUE(column_name) OVER (PARTITION BY ... ORDER BY ...)：查詢該分區最後一列資料 -- 找出各部門裡「最早錄用員工的錄用日期」，分別顯示在各部門員工欄位右側 SELECT name, DATE(hiredate), department_id, DATE(FIRST_VALUE(hiredate) OVER (PARTITION BY department_id)) AS dept_earliest_hiredate FROM employee; 參考資料： SQL 窗口函數 Window Function：三大應用快速教學 ","description":"SQL 自學筆記——CTE＆Window Function","tags":["learning","SQL","CTE","Window Function"],"title":"SQL - CTE(Common Table Expression)＆Window Function","uri":"/post/2025/sql/cte_and_windowfunction_20250503/"},{"content":"第二週：4/14、4/15、4/17、4/19 It is not things themselves that disturb us, but our opinions about them. — Epictetus\n相同功能/達成結果相同情況下，Recursive (call stack) 比for loop更占記憶體空間（∵Heap）\nRecursive 每一次呼叫，程式會分配一塊stack frame(堆疊空間)給該函數，並保留目前狀態，等待下一層遞迴回傳後再繼續執行 導致每層呼叫都佔據一些記憶體 for loop 每個只要一次函數呼叫的堆疊空間，不會有額外的函數呼叫堆疊 除非每圈都創造很多objects，否則使用空間是固定的 python有堆疊上限: 預設1000層(可用 sys.getrecursionlimit() 查看) import sys print(sys.getrecursionlimit()) 超過就會 RecursionError: maximum recursion depth exceeded in comparison → 無法回傳或Crash或記憶體爆炸 函式也可指派給變數 –\u003e 類似代數中「變數可以代表一個值」的觀念\n函式也是物件（objects） def square(x): return x * x def cube(x): return x * x * x def operate(func, value): return func(value) print(operate(square, 3)) # 9 print(operate(cube, 3)) # 27 Higher-order Functions(高階函式): 「接受其他function作為參數」或「回傳function作為結果」的Function python內建如map(func, iterable)、filter(func, iterable)、sorted(iterable, key=func) lambda\nAnonymous Function （匿名函式）的一種 結構：lambda parameters : expression Web Crawling BeautifulSoup select() vs. find() select(): CSS 選擇器風格查詢，可單區塊深入查內層 可用 CSS selector 語法（ex. div \u003e span.title） find(): 條件搜尋式，用 tag 名、class、id 當參數，查詢廣範圍但難深入 # 用 find() 抓到區塊，再用 select() 查裡面的內容 box = soup.find(\"div\", class_=\"container\") title = box.select_one(\"span.title\") # select_one 會直接回傳單一元素 package(browser-cookie3) 針對需要登入才能瀏覽的網站\n自動fetch瀏覽器cookies\nimport browser_cookie3, requests # 從 Chrome 瀏覽器中取得 cookies cj = browser_cookie3.chrome() # 回傳一個 cookie jar # 帶著 cookies 發送 GET 請求 res = requests.get('https://example.com', cookies=cj) print(res.text) 登入了一個網站（例如 Twitter、Google、Facebook 等）後，browser-cookie3可借用(存在本機的)瀏覽器登入的 cookies (session token)去存取相同網站的資料 適用於爬某些私人頁面（如個人FB 、學校系統等），但要小心 dynamic website e.g. nownews – 找點擊「載入更多」後的request url 抓多頁==\u003e 抓網址id規律 規律不明顯的話就抓大概，搭配去重(都存進set；或用dict，把每篇url最後id當成key也可以) Pandas 儲存格式 parquet format: 列式儲存格式，I/O效率高、壓縮比高、儲存空間小；通常搭配 pyarrow 或 fastparquet python pickle format: python自己的物件序列化格式；跨語言、跨平台、跨版本python不一定相容；適合快速暫存；安全風險–不明來源的pickle可能被植入惡意代碼 自補充 Separate data (or settings/configuration) from logic 把邏輯和資料分開 「關注點分離」（Separation of Concerns） 把 Logic(處理流程、資料運算、檔案操作等核心功能) 跟 Settings(target 名稱、輸出位置、參數開關等使用者可修改的項目) 分開 良好習慣 不要把一些可變的參數（像使用者指定的輸出檔案檔名、ID、URL等）硬寫在程式碼裡面，而是要集中放在一個設定檔（config file）裡管理 ❌程式碼中某一行直接寫： target = \"123\" # 請自行更改檔案名稱 filename = f\"{target}.txt\" ✅使用設定檔如 config.json，再讓程式讀檔： { \"target\": \"123\" } import json with open(\"config.json\", \"r\", encoding=\"utf-8\") as f: config = json.load(f) target = config[\"target\"] filename = f\"{target}.txt\" Prevention事前預防 vs. Recovery事後處理 e.g.讓使用者輸入數字 ==\u003e 避免輸入非數字 Prevention: 用regex檢查 避免 try-except 的開銷（雖然通常微乎其微） 適合「錯誤不是預期中流程的一部分」的場景（例如輸入驗證） 缺點：要自己處理各種邊界條件（空字串、負號、小數點、全形字元……） import re user_input = input(\"請輸入數字: \") if re.fullmatch(r'\\d+', user_input): # re.fullmatch--\u003e整串輸入都要符合規則 number = int(user_input) else: print(\"Error: 請輸入合法的整數\") Recovery: try-except 更符合 「EAFP」（Easier to Ask Forgiveness than Permission）原則 —— 一種 Python 的設計哲學 相對於EAFP \u003c—\u003e LBYL(Look Before You Leap) 精簡、直觀：直接嘗試做「你希望做的事」，失敗再處理 缺點：對於Expected Errors(預期性錯誤，非常常見、幾乎一定會發生)來說，不夠精準（會包住太多可能錯誤） Prevention: 使用者輸入 / 格式驗證；邏輯精密 / 錯誤類型需精細掌握者 Recovery: 無法預測的錯誤（網路錯誤、檔案損壞）；簡單任務 / 不在乎精細錯誤類型 其他自學 Hello 演算法\n實體書\n岡野原大輔 (2024). 精確掌握 AI 大趨勢！深度學習技術解密：日本 AI 神人，帶你正確學會從機器學習到生成式 AI 的核心基礎 (王心薇 \u0026 施威銘研究室, Trans.). 旗標. Ceder, N. (2019). Python 技術者們：練功！老手帶路教你精通正宗 Python 程式 (張耀鴻, Trans.). 旗標. Udemy線上課程\nAPI(Application Programing Interface, 應用程式界面) API Endpoint: location, URL Request 【library】: requests .raise_for_status(): (當如果不是200通過) raise一個requests.exceptions.HTTPError，讓使用者集中處理API請求時的HTTP errors e.g. International Space Station Current Location http status code: 1xx: hold on 2xx: here you go 3xx: go away 4xx: you screwed up 5xx: the site screwed up HTML Entities – HTML特殊字元編碼表/字符實體 避免跟HTML特殊字元混淆，如 \u003c 須改用HTML Entity的寫法：\u0026lt; import html unescaped_words = html.unescape(escaped_str) tkinter self.false_button = Button(image=self.cross_img, highlightthickness=0, command=self.quiz.check_answer(\"False\")): 後半部不能command=self.quiz.check_answer(\"False\")，command要的是method名稱，要到按鈕點擊時才會執行function，原本寫法會等於是「馬上執行 check_answer(“False”)」 –\u003e 可用lambda寫法或是另外定義一個def func引入 李宏毅【生成式AI時代下的機器學習(2025)】\n李宏毅【生成式AI導論 2024】\n張成龍【MySQL資料庫從零開始玩轉】\n","description":"當周學習與生活雜記","tags":["learning","journal"],"title":"轉職路：AI養成班 Week 2.","uri":"/notes/2025/weekly_journal_202504_2/"},{"content":"Python實作 Bubble Sort ※排序演算法(Sorting Algorithm)是將資料依特定規則進行重新排列的演算法，通常是依照資料的大小進行排列，Bubble Sort是其中之一。\n※資料排序後，就能進一步對其進行更有效率的分析或搜尋。如「二分搜尋法」在資料數較多時，效率高於循序搜尋，但執行二分搜尋之前，必須先將原始資料排序。\n程式碼 def user_input_check(message): while True: try: user_input = input(message) if '.' not in user_input: return int(user_input) else: return float(user_input) except ValueError: print(\"請輸入正確的數字...\") def bubble_sort(number_list): for i in range(1, len(number_list)): print(f\"### 第{i}輪 ###\") for j in range(len(number_list) - i): if number_list[j] \u003e number_list[j + 1]: number_list[j], number_list[j + 1] = number_list[j + 1], number_list[j] print(f\"\u003e\u003e資料狀態: {number_list}\") print(\"-------------------\") return number_list print(\"———請輸入以下資訊———\") data_length = 0 while data_length \u003c= 0: data_length = int(user_input_check(\"資料總數量：\\n\")) data_list = [] for num in range(data_length): data_list.append(user_input_check(f\"第{num + 1}筆資料: \")) print(f\"\\n\\n原始資料:{data_list}\") print(\"-------------------\") sorted_list = bubble_sort(data_list.copy()) print(f\"排序後資料: {sorted_list}\") 執行畫面 說明 上面程式碼是自己練習寫的，可能不是最好的bubble sort寫法 user_input_check(message): 輸入檢查，跟bubble sort無關，只是習慣放 bubble_sort(number_list): 排序法本體，外層 for loop 控制排序的輪數，每輪最後會把一個最大值排到最右側；內層 for loop 進行相鄰元素比較與交換 值得一提是中間 number_list[j], number_list[j + 1] = number_list[j + 1], number_list[j] ，這種寫法是Python特有的，涉及 tuple 型別的 packing / unpacking ，一行就能交換兩變數值 如果是其他程式語言，要兩數互換大多需要再一個temp變數，分三行如 temp=var1、var1=var2、var2=temp 從巢狀for loop就能看出bubble sort的時間複雜度是O(n²)，效率差，實務上基本沒人會用。但就入門迴圈邏輯＆資料操作思維來說，應該還是有幫助。至少我希望有幫助…✏️ ","description":"氣泡排序法（泡沫排序法）練習","tags":["learning","algorithm","sorting","bubble sort"],"title":"Python 實作 Bubble Sort","uri":"/post/2025/algorithm/bubble_sort_20250414/"},{"content":"第一週：4/7、4/8、4/10、4/12 自我介紹環節，有不少資訊本科系或做過科技業，甚至還有自費生，真心佩服。 簡單翻了一下歷屆學長姐成果，從電腦視覺到混合應用的都有。該來想想專題的主題了（小組專題＆個人的Side Project）。希望結訓後履歷至少能塞滿一整頁。 使用者家目錄 C:\\Users\\[USER-NAME]\\ // 動態（隨登入者變化） // 登入者(USER)對家目錄有最高權限 Adding Python Path to Environment Variables Zero Trust pypi.org encode/decode history: ASCII -\u003e BIG-5 -\u003e Unicode(UTF-8/UTF-16…) character set（字元集） f-string: {}(Curly Brackets)內必須為expression (表達式) statement(敘述句,如print())等無回傳值的不應放入(會None) str.format() (\"[pattern]\".format(a,b,c…)) print(\"他是 {}，今年 {} 歲。\".format(\"Johnny\", 88)) # 輸出：他是 Johnny，今年 88 歲。 float非精準數，比對時以區間比對較佳 a = 100.0 b = 11.11 / 0.1111 print(f\"a 等於 b ? --\u003e {a == b}\") # a 等於 b ? --\u003e False print(f\"a: {a} | b: {b}\") # a: 100.0 | b: 99.99999999999999 eval() x = eval(input(\"Input:\")) # eval()自動評估數字型別＆轉換 # 不適用非數字 match-case rating = 5 match rating: case 1: print(\"第1名，獎金10,000元！\") case 2: print(\"第2名，獎金5,000元\") case 3 | 4 | 5 as number: # 後置宣告 -- as print(f\"佳作(第{number}名)，獎金500元\") case _: print(\"下次再接再厲！\") # Tuple niceSeasons = (\"春\", \"秋\") match niceSeasons: # 元素順序要一致，否則比對失敗: case (\"秋\", \"春\"): print(\"溫和季節\") case _: print(\"季節比對失敗\") 自補充 f-string 細節 若數字num是正整數如 7 ，f\"{num:02d}\" 和 f\"{num:0\u003e2}\" 結果看起來會一樣 num = 7 print(f\"{num:02d}\") # 07 print(f\"{num:0\u003e2}\") # 07 但兩種 format 背後邏輯不一樣： num:02d –\u003e 數值格式化 : 「將變數 num 格式化成一個 最小寬度為 2 位數 的十進位整數(Decimal Integer)，如果不足 2 位，則在前面補 0 。 num:0\u003e2 –\u003e 字串對齊格式化 : 「把 num 轉成 string 後，向右對齊(\u003e)，若num轉成string後，長度沒達到設定的『最小寬度』 2 ，則在左側補 0 直到寬度達標為止」。 因此如果碰到負數等特殊情況，第二種方式可能會出現錯誤的顯示，如： i = -42 print(f\"{i:05d}\") # ✅-0042 print(f\"{i:0\u003e5}\") # ❗00-42 p.s. num:0\u003e2 這種方式，若num本身長度就大於設定的「最小寬度(2)」，則Python 會自動擴展欄位，完整顯示數值，不受限。 Disbale path length limit after installed 假如裝 python 時沒勾選。安裝完畢後： modify the registry key: Windows Key + R, type “regedit” “Computer\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\FileSystem\\LongPathsEnabled” –\u003e set its value to 1 Web Crawling tags \u003clabel for=\"name\"\u003eName:\u003c/label\u003e \u003cinput type=\"text\" id=\"name\" name=\"name\"\u003e for=“xxx” \u003c–\u003e id=“xxx” ∴點擊上面Name:的字，連動到input框閃爍可輸入，不必一定要點擊input框 type=\"hidden\" : 僅給開發者使用/確認, or 加上時間戳記,檢核、防爬蟲等 網頁上有name=\"\"標籤的通常會被form送出 動態網頁 cookie Headers Status Code Rest API payload pyenv – Python version control ETL Poetry 其他自學 Hello 演算法\n~ 4.2 從位址計算公式的角度看，索引本質上是記憶體位址的偏移量。首個元素的位址偏移量是0 ，因此陣列首個元素的索引為0是合理的 由於陣列的長度是固定的，因此插入一個元素必定會導致陣列尾部元素“丟失” 刪除元素完成後，原先末尾的元素變得“無意義”，所以無須特意去修改 import numpy as np # 建立一固定長度的 numpy 陣列 arr = np.array([10, 20, 30, 40, 50]) print(\"原始陣列：\", arr) # 插入一個元素到index[2]，並移動後面的元素 # 手動模擬插入（ numpy 不像 list 可以直接 insert） arr[3:] = arr[2:-1] # 往後推一格 arr[2] = 99 # 插入新值 print(\"插入 99 後：\", arr) # 原本的 50 被擠掉了 # 刪除索引 1 的元素（把後面的往前搬） arr[1:-1] = arr[2:] print(\"刪除索引 1 後：\", arr) # 最後一格雖然還有值，但已經是「無意義」的資料 print(\"最尾端元素實際上已經沒用了：\", arr[-1]) 自架 GitHub + Hugo 靜態網站(https://ah-devworks.github.io//tags/hugo/)：\nUI(font, i18n/[language] yaml, favicon)、footer調整 技術彙整大致完成，剩餘額外補充待整理 網站尚有改善空間（Google Analytics、SEO…），但反正能用了，先暫時這樣堪用就好 實體書\n岡野原大輔 (2024). 精確掌握 AI 大趨勢！深度學習技術解密：日本 AI 神人，帶你正確學會從機器學習到生成式 AI 的核心基礎 (王心薇 \u0026 施威銘研究室, Trans.). 旗標. 讀到第二章 順便根據其中2.1節額外找 最小平方法(Least Squares)教學，雖然現在機器學習應該都不是用OLS了 Ceder, N. (2019). Python 技術者們：練功！老手帶路教你精通正宗 Python 程式 (張耀鴻, Trans.). 旗標. 中文是根據3rd Edition翻譯的，查了一下原作者Naomi Ceder今年有4th Edition 以英文4th edition為主、中文3rd Edtion為輔，讀到2.3.2 目前比較明顯差異是不再要求裝Anaconda之類的IDE，改用Google Colab hosted Jupyter Notebook放範例 Jupyter筆記本由兩種類型的單元格組成：文本單元格和代碼單元格 Udemy線上課程\nsmtplib 網路託管：PythonAnywhere smtplib的涉及個人信箱帳密，還是別放到網上比較好 其他一些無關且須重複執行的project倒是可以託管 進度嚴重落後，這周弄靜態網站花太多時間了🫠 ","description":"當周學習與生活雜記","tags":["learning","journal"],"title":"轉職路：AI養成班 Week 1.","uri":"/notes/2025/weekly_journal_202504_1/"},{"content":"自架網站筆記：使用Github + Hugo（上） 自架網站筆記：使用Github + Hugo（中） 目錄 更新靜態網站內容的方法 常見QA \u0026 Tips 更新靜態網站內容的方法 把新內容準備好（Markdown, image等檔案要放到Content-Repo裡各自對應的子資料夾），更新push。 git add . git commit -m \"新增文章：new-post\" git push origin main # 如果檔案較多較大，push後建議等一下 確認前一步驟content-repo已經上傳、更新好了之後，轉到Web-Repo 🌟Web-Repo 更新submodule: git submodule update --remote (可選) git status 檢查content-repo檔案有引入 git add [檔案] 後，可以先 hugo server 本地確認網站更新無誤；或直接 hugo 後把 public/ 內新檔覆蓋更新到母資料夾 git add . –\u003e git commit –\u003e git push origin main ，過幾分鐘 github 處理好，刷新網站即可。 可以到github 的web-repo檢查進度（如下圖✅｜萬一出現❌表示哪裡出了問題，要回頭檢查） 常見QA \u0026 Tips 【本機跑正常，GitHub Pages 樣式卻很簡陋】：一路做到PART III都沒問題，但實際網址連到的網頁外觀卻跟「hugo server」測試時「http://localhost:1313/…」的網頁明顯不同。 通常是baseURL沒設定好，或是publish的相對路徑、theme路徑或資源沒有正確被拷貝，導致Github Pages抓不到樣式 建議前述PART I的步驟7第二點再次確認：baseURL應該會是「https://[你的使用者名稱].github.io/」 確認hugo生成的public檔案必須全部拷貝到前一層資料夾（通常就是「/[你的使用者名稱].github.io」） 且每次修正後，都要重新hugo、update一次，讓Github Pagese更新（通常push後不會即時刷新，要等一下 –\u003e 可看github倉庫-Settings-Pages網站網址底下的小字「Last deployed by @user xxx minutes ago」來判斷刷新了沒） 有時候可能是theme本身的問題，假如theme本身有exampleSite（contents, layout等資料夾），建議可以複製回去、保持樣式，之後再來把範本內文取代掉 修改網站圖示(Favicon / Website Icon) 瀏覽網頁時，畫面上方網頁名稱的旁邊的那個小icon就是Favicon，預設會是主題自帶的icon。 製作 Favicon : 可以用 favicon.io 或 RealFaviconGenerator 之類的免費網站；懂PS的話也可以自己做，記得縮成512x512再轉成 .ico 或 .png 格式。 把Web-Repo/static/favicon 底下的檔案替換掉，重新hugo就行。 個人心得 拿關鍵字去google能找到很多「X分鐘快速架設網站」的文章或影片，但實際操作發現比較適合「就只是要個網站放些簡單文章/日記而已」的人，要多些功能的話，那複雜度就會開始上升了。 就我個人而言，首先構思網站的架構、層級劃分、文章類型就花了些時間； 挑theme又花了些時間，第一個挑的theme在clone時還碰到一堆缺少前製套件之類的奇怪狀況……； 再來又開始想「要把Content-Repo當成submodule？還是反過來把Web-Repo當成Content-Repo的sub？」之類，攸關彈性跟未來維護性等等的問題…… 明明簡單來說就只有兩個repo而已，花了快10小時，至少打掉重來三次……可能我是資質比較駑鈍的那種吧( 之後或許會不定期更新有關UI調整、自動部署（GitHub Actions/Hugo Deploy）、Project導入等等的筆記。 有任何疑問歡迎私信我 只是回信可能比較慢，請見諒。要是一直沒回覆，可以隔週再寄一次。\n— A.H.Dev-Works.\n參考資源 HUGO Docs Creating a Blog with Hugo and Github in 10 minutes –\u003e 注意這教的是把Web-Repo當成submodule的方法 【懶人包】使用 Hugo 5 分鐘內快速架設個人網站，號稱現在最快的自架網站方式 –\u003e 主要參考Hugo 從零開始: 用github pages 上傳靜態網站 Lightbi-Demo genryu-font ","description":"——自架靜態網站的過程紀錄．下篇——","tags":["hugo","blog","website"],"title":"自架網站筆記：使用Github + Hugo（下）","uri":"/post/2025/website/create_static_web_3/"},{"content":"【前一回】自架網站筆記：使用Github + Hugo（上） 目錄 PART II : 設定內容倉庫（Contents-Repo） PART III : 部署網站到 GitHub Pages PART II : 設定內容倉庫（Contents-Repo） 本地另一個資料夾clone「放網站內容的repo（PART I步驟3建立的Contents-Repo）」 同樣初始化 touch README.md echo \"# [Contents-Repo]\" \u003e README.md git add README.md git commit -m \"Initial commit\" git push origin main 建立內容結構/資料夾 這裡可按照自己需要的層級或theme建議的層級來做 mkdir content cd content mkdir notes post 注意\r結構資料夾要包含Hugo在building網站時需要的各子資料夾\r通常是「contents」、「static」這兩個資料夾，但也不一定，建議翻查主題的Documents，有寫最好，沒寫的話就只能自己多hugo server測試幾次。\n建立一篇測試文章，如 echo -e \"+++\\ntitle = \\\"First Note\\\"\\ndate = 2025-04-05\\n+++\\n\\nThis is my first note.\" \u003e content/notes/first-note.md 或自己寫一個.md檔 push上去 注意這裡不要執行 hugo new site，Contents-Repo只負責網站上的內容檔案 [2025/04/11 更新] 6. 把Content-Repo的檔案（content/資料夾裡的.md文件 ＆ 可能有static/裡的圖片等額外檔案）確認都ok後，在這個資料夾先git add -\u003e commit -\u003e push 一次後，手動複製 content/ static/兩資料夾到 Web-Repo/ 底下，覆蓋更新原本Web-Repo/裡面的同名資料夾跟檔案 註: 原本submodule引入的方式太複雜，也容易出錯，反正兩個repo的檔案都在同一電腦本機，乾脆版本管理用各自的git，移動用手動的處理比較快。 再次 hugo server 測試，正確的話原本在Contents-Repo裡面的文章（步驟4做的）應該會顯示在網站對應的地方（如網站 [Notes] 標籤底下） 沒問題的話記得Web-repo 也要 push提交更改。 之後主要寫日記、文章、圖片都在Content-Repo進行，完成後git版本更新，再複製進Web-Repo/ 後 hugo，Web-Repo/也記得每次都要版本更新。這樣萬一哪次檔案不小心誤刪或蓋掉，還是可以回溯。 PART III : 部署網站到 GitHub Pages 生成靜態檔案：在Website-Repo用 hugo指令，在其下的 public/ 資料夾生成靜態網站檔案 把public/資料夾裡已生成的靜態網站全部檔案挪到前一層（手動把檔案複製貼上也可以） cp -r public/* . 提交 git add . git commit -m \"Generate static site\" git push origin main 再次add -\u003e commit -\u003e push 檢查網站是否正常顯示（github倉庫-Settings-Pages會顯示「Your site live at https://...」） 做到這，網站其實就算是架好了，其他細節跟QA放在下篇。 自架網站筆記：使用Github + Hugo（下） ","description":"——自架靜態網站的過程紀錄．中篇——","tags":["hugo","blog","website"],"title":"自架網站筆記：使用Github + Hugo（中）","uri":"/post/2025/website/create_static_web_2/"},{"content":" 第一篇文章，總之先簡單記錄這個靜態網站怎麼做的，不然大概隔幾天又忘光光。 原本只打算寫給自己複習用，所以有些我已經懂的部份（像是Git）寫比較簡單。如果有緣的你無意看到這篇，想看懂，但看不懂，歡迎私信我。 如果你/妳看到這篇文章的時候，網站已經有留言功能，也歡迎留言詢問。 目錄 PART 0 : 在動手之前 - 關於這個靜態網站 PART I : 基礎設定 PART 0 : 在動手之前 - 關於這個靜態網站 預先構想這個網站會由兩大部份（2 repositories）構成：\nWebsite-Repo：負責靜態網站呈現（用 Hugo build 出來的 HTML/CSS/JS）。 Contents-Repo：放原始內容（markdown，如 content/notes、content/diary）。 未來更新內容主要會在 Contents-Repo，然後將生成的網站部署到 Website-Repo。 也會將其他專案 repo（像 side projects）整合進這個 Hugo 網站。 行有餘力再多加上其他功能（Google Analytics, SEO, comments） PART I : 基礎設定 已經有github帳號 Windows winget install Hugo.Hugo.Extended 安裝Hugo（建議安裝 Hugo Extended版本，方便後續自訂模板樣式） github新建兩個repo：一個放內容（Contents-Repo），一個負責網站本身(Website-Repo. – ex.AH-DevWorks.github.io)，分別clone到本地的資料夾（這時兩個倉庫都還是空的，正常） 建議\r上述操作需要有「git」以及「github」的基礎理解，如果不懂的話，請先關鍵字google或問AI。\r初始化git分支 touch README.md echo \"# [Website-Repo]\" \u003e README.md git add README.md git commit -m \"Initial commit\" git push origin main 本地clone放網站內容的repo，hugo new site . 設在母資料夾較佳，建議別再額外新增如 hugo new site [MySite etc.]，否則後續要每次都手動挪動/public或額外設定自動腳本，會很麻煩。 若母資料夾已有內容（如README.md），則用 hugo new site . --force 等Hugo自動建立好內容後，cd到themes資料夾；挑個Hugo的theme，照著說明來裝（例如clone 到 themes資料夾，或用Git submodules處理） {{/* \u003c info_cards header=“suggest” title=“這裡以Lightbi為例” content=“https://themes.gohugo.io/themes/lightbi-hugo/\" \u003e */}} 把這個theme設成預設： 回到步驟5建立好的母資料夾，vi hugo.toml 編輯toml內容： A. [baseURL]改成步驟3負責網站本身的repo網址(通常是https://[user_name].github.io/)；B. [title]改隨意（會顯示在網站上）；C. [theme]改成前幾步驟挑選的 關於hugo.toml參數\r參數與功能跟主題密切相關，建議先翻看主題給的Documents。以Lightbi為例，參數的說明就放在Demo網站的文章裡：https://lightbi-hugo-theme.netlify.app/en/post/2020/parameters/\r初步測試：hugo server，應該會有空白模板或theme預設範本網頁 有些theme偏舊，這步會出現問題，直接換一個theme比較省事 正確的話bash或cmd會顯示網站生成的頁數、靜態檔案數量等資訊 找到其中Web Server is available at http://localhost:1313/...這行，貼到瀏覽器，有出現看起來像網頁的樣子就對 確認ok後要再提交一次更改到github git add . git commit -m \"Set up website with theme\" git push origin main 【下一回】自架網站筆記：使用Github + Hugo（中） ","description":"——自架靜態網站的過程紀錄．上篇——","tags":["hugo","blog","website"],"title":"自架網站筆記：使用Github + Hugo（上）","uri":"/post/2025/website/create_static_web_1/"}]
